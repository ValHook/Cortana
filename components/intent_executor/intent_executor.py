from datetime import datetime
from datetime import tzinfo
from dateutil import tz
import dateparser
from components.api_fetcher.api_fetcher import Fetcher
from components.converters.when import to_datetime
from components.img_generator.img_generator import Generator
from components.storage.storage import Storage
from protos.activity_pb2 import Activity
from protos.intent_pb2 import Intent
from protos.schedule_pb2 import Schedule

CLEARPAST_WEEKDAY = "Tuesday"
CLEARPAST_HOUR = 19
TIMEZONE = tz.gettz('Europe/Paris')
MAX_SQUAD_SIZE_PLAYERS = 6
MIN_SQUAD_SIZE_PLAYERS = 1
MAX_SQUAD_SIZE_SUBSTITUTES = 2
MIN_SQUAD_SIZE_SUBSTITUTES = 0


class Executor:
    """Executor for user input (intents)."""

    def __init__(self, storage, api_fetcher, img_generator):
        assert isinstance(storage, Storage), "Stockage non configuré"
        assert isinstance(api_fetcher, Fetcher), "Connexion API non configurée"
        assert isinstance(img_generator, Generator), "Générateur d'images non configuré"
        self.__storage = storage
        self.__api_fetcher = api_fetcher
        self.__img_generator = img_generator

    def execute(self, intent, now):
        """
        :param intent: The intent to execute
        :param now: Now as a datetime.
        :return: An (execution feedback message, generated BytesIO images or None) tuple.
        :raises: If the intent could be executed for some reason.
        """
        assert isinstance(intent, Intent), "Commande invalide"
        assert isinstance(now, datetime), "Horloge non configurée"
        assert isinstance(now.tzinfo, tzinfo), "Fuseau horaire non configuré"
        if intent.HasField('global_intent'):
            return self.execute_global_intent(intent.global_intent, now)
        if intent.HasField('activity_intent'):
            return self.execute_activity_intent(intent.activity_intent), None
        raise ValueError("Commande invalide")

    def execute_global_intent(self, global_intent, now):
        """
        :param global_intent: The global_intent to execute.
        :param now: Now as a datetime.
        :return: An (execution feedback message, generated BytesIO images or None) tuple.
        :raises: If the intent could be executed for some reason.
        """
        if global_intent.HasField('credits'):
            #! raid credits
            return "Mes créateurs sont Walnut & Oby ❤️", None

        if global_intent.HasField('help'):
            # !raid help
            help_str = "Guide d'utilisation:\n" \
                "Le bot gère et génère les affiches d'un planning d'activités.\n" \
                "Il connaît les noms et les niveaux d'expérience des joueurs de la FE11 " \
                "et des clans alliés.\nCe guide détaille les commandes pour utiliser le bot.\n" \
                "Dans toutes les commandes détaillées ci-dessous il faut savoir que: \n\n" \
                "-[nom activité] " \
                "doit être remplacé par un vrai nom, style calus, fleche, fleau, jds, couronne, " \
                "etc... Plusieurs formats sont supportés (e.g. leviathan, jardin du salut, " \
                "couronne du malheur, flèche prestige, flèche d'étoiles prestige marchent aussi)." \
                " Les fautes d'orthographe sont aussi gérées dans la limite du raisonnable. " \
                "(e.g. kalus, fleo, devorer, etc... sont aussi supportés).\n\n" \
                "- (date) peut être remplacé par une date ou ignorée. Plusieurs formats de date " \
                "sont gérés (e.g. mercredi, 17/08, dimanche 21h, demain 22h30, 20/8 20h30, "\
                "etc...)\nLa date est utile pour 2 cas de figures:\n" \
                "1) Afficher la date sur les affiches.\n" \
                "2) Différencier deux activités du même type dans une commande.\n" \
                "La date peut généralement être ignorée dans une commande qui modifie " \
                "les détails d'une activité qui est la seule de son type dans le planning.\n\n" \
                "- [date] indique une date obligatoire. Par exemple pour la commande de " \
                "modification d'une date d'activité.\n\n" \
                "- [gamer_tags] indique une liste de gamer tags (au minimum 1 gamer tag).\n" \
                "Le bot est capable de comprendre et corriger les gamer tags même si ils sont mal" \
                " ortographiés. (e.g. cosa, croptus, darklight, franstuck, hartok etc...)\n\n\n" \
                "Liste des commandes: \n\n" \
                "!raid [nom activité] (date) [gamer_tag1, ...] => Créé/modifie une escouade pour/" \
                "d'une activité. Précédez un gamer tag par '-' pour signaler que le joueur doit" \
                " être retiré et non ajouté.\n\n" \
                "!raid backup [nom activité] (date) [gamer_tag1, ...] => Pareil que la commande " \
                "du dessus mais pour gérer les remplaçants.\n\n" \
                "!raid date [nom activité] (ancienne date) [nouvelle date] => Ajoute ou modifie " \
                "une date à une activité.\n\n" \
                "!raid milestone [nom activité] (date) => Précise une save ou un statut pour " \
                "l'activité concernée. (e.g. !raid milestone jds save au boss, " \
                "!raid milestone leviathan prestige reporté)." \
                "!raid finish [nom activité] (date) => Marque l'activité comme terminée.\n\n" \
                "!raid info [nom activité] (date) => Affiche les détails de l'activité dans un " \
                "format texte.\n\n" \
                "!raid clear [nom activité] (date) => Supprime l'activité du planning.\n\n" \
                "!raid images => Génère les affiches pour toutes les activités du planning.\n\n" \
                "!raid help => Affiche le guide d'utilisation.\n\n" \
                "!raid infoall => Affiche tout le planning dans un format texte.\n\n" \
                "!raid clearpast => Supprime toutes les activités des semaines précédentes.\n\n" \
                "!raid clearall => Supprime toutes les activités.\n\n" \
                "!raid sync => Synchronise la liste des joueurs et leurs stats.\n" \
                "Utile quand des nouveaux membres rejoignent le clan.\n" \
                "Utile pour que le bot soit au courant des changements de niveaux d'expérience " \
                "des joueurs.\nAttention toutefois, les changements de niveaux d'expérience ne " \
                "sont pas directement reflétés dans les affiches. " \
                "Ils seront appliqués à partir des prochaines commandes (nouvelle création " \
                "d'activité ou mise à jour d'escouade).\n\n" \
                "!raid lastsync => Affiche la dernière date de synchronisation.\n\n" \
                "!raid credits => Affiche les noms de mes créateurs."
            return help_str, None

        if global_intent.HasField('generate_images'):
            # !raid images
            schedule = self.__storage.read_schedule()
            images = self.__img_generator.generate_images(schedule)
            if len(images) == 0:
                return "Il n'y a aucune activité dans le planning pour le moment.", []
            return "Affiches pour les activités en cours:", images

        if global_intent.HasField('sync_bundle'):
            # !raid sync
            bundle = self.__api_fetcher.fetch(now)
            self.__storage.write_api_bundle(bundle)
            return "Joueurs et niveaux d'experiences synchronisés.", None

        if global_intent.HasField('get_last_bundle_sync_datetime'):
            # !raid lastsync
            bundle = self.__storage.read_api_bundle()
            return "Dernière synchronisation: " + bundle.last_sync_datetime, None

        if global_intent.HasField('clear_all'):
            # !raid clearall
            schedule = Schedule()
            self.__storage.write_schedule(schedule)
            return "Toutes les activités du planning sont désormais supprimées.", None

        if global_intent.HasField('clear_past'):
            # !raid clearpast
            schedule = self.__storage.read_schedule()
            threshold = dateparser.parse(
                CLEARPAST_WEEKDAY,
                settings={'PREFER_DATES_FROM': 'past', 'RELATIVE_BASE': now}
            )
            threshold = threshold.replace(hour=CLEARPAST_HOUR)
            threshold = threshold.replace(tzinfo=TIMEZONE)
            activities = filter(
                lambda a: not a.id.when or threshold <= to_datetime(a.id.when, now.tzinfo),
                schedule.activities
            )
            schedule = Schedule()
            schedule.activities.extend(activities)
            self.__storage.write_schedule(schedule)
            feedback = "Les activités des semaines précédentes ont été suprimées.\n"
            feedback += "Les activités restantes dans le planning sont:\n"
            feedback += str(schedule)
            return feedback, None

        if global_intent.HasField('info_all'):
            # !raid infoall
            schedule = self.__storage.read_schedule()
            return str(schedule) if len(schedule.activities) > 0 else "Le planning est vide.", None

        raise ValueError("Commande invalide")

    def execute_activity_intent(self, activity_intent):
        """
        :param activity_intent: The global_intent to execute.
        :return: An execution feedback message tuple.
        :raises: If the intent could be executed for some reason.
        """
        schedule = self.__storage.read_schedule()
        activity_id = activity_intent.activity_id
        if activity_intent.HasField('update_when'):
            # !raid date
            activity = self.find_activity_with_id(activity_id, schedule)
            activity.id.when.CopyFrom(activity_intent.update_when)
            self.__storage.write_schedule(schedule)
            return "Date mise à jour:\n" + str(activity.id)

        if activity_intent.HasField('mark_finished'):
            # !raid finish [activity] (date)
            activity = self.find_activity_with_id(activity_id, schedule)
            activity.state = Activity.State.FINISHED
            self.__storage.write_schedule(schedule)
            return "Good job!\nActivité marquée comme terminée:\n" + str(activity.id)

        if activity_intent.HasField('set_milestone'):
            # !raid milestone [activity] (date)
            activity = self.find_activity_with_id(activity_id, schedule)
            activity.state = Activity.State.MILESTONED
            activity.milestone = activity_intent.set_milestone
            self.__storage.write_schedule(schedule)
            return "Étape mise à jour (" + activity.milestone + "):\n" + str(activity.id)

        if activity_intent.HasField('info'):
            # !raid info
            activity = self.find_activity_with_id(activity_id, schedule)
            return str(activity)

        if activity_intent.HasField('clear'):
            # !raid clear [activity] (date)
            activity = self.find_activity_with_id(activity_id, schedule)
            schedule.activities.remove(activity)
            self.__storage.write_schedule(schedule)
            return "Activité supprimée:\n" + str(activity.id)

        if activity_intent.HasField('upsert_squad'):
            # !raid (backup) [activity] (date) [players]
            feedback = "Escouade mise à jour"
            try:
                activity = self.find_activity_with_id(activity_id, schedule)
            except:
                activity = schedule.activities.add()
                activity.id.CopyFrom(activity_intent.activity_id)
                activity.state = Activity.State.NOT_STARTED
                feedback = "Activité créée"
            self.merge_players(
                activity.squad.players,
                activity_intent.upsert_squad.added.players,
                False
            )
            self.merge_players(
                activity.squad.players,
                activity_intent.upsert_squad.removed.players,
                True
            )
            self.merge_players(
                activity.squad.substitutes,
                activity_intent.upsert_squad.added.substitutes,
                False
            )
            self.merge_players(
                activity.squad.substitutes,
                activity_intent.upsert_squad.removed.substitutes,
                True
            )
            self.assert_player_count_within_bound(
                activity.squad.players,
                MIN_SQUAD_SIZE_PLAYERS,
                MAX_SQUAD_SIZE_PLAYERS
            )
            self.assert_player_count_within_bound(
                activity.squad.substitutes,
                MIN_SQUAD_SIZE_SUBSTITUTES,
                MAX_SQUAD_SIZE_SUBSTITUTES
            )
            self.__storage.write_schedule(schedule)
            return feedback + ":\n" + str(activity)

        raise ValueError("Commande invalide")

    def find_activity_with_id(self, activity_id, schedule):
        """
        Finds the activity that best matches the given ID.
        :param activity_id: The activity ID used for the search.
        It can be incomplete (i.e without the When)
        :param schedule: The planning to search from.
        :return: The desired match.
        :raises: If there are 0 or more than 1 matches.
        """
        activities = schedule.activities
        activity_type = activity_id.type
        date_time = to_datetime(activity_id.when, TIMEZONE)
        date = date_time.date() if date_time else None
        search_by_type = date_time is None
        search_by_date = not search_by_type and not activity_id.when.time_specified
        search_by_datetime = not search_by_type and not search_by_date

        # Search by type.
        if search_by_type:
            activities = filter(lambda a: a.id.type == activity_type, schedule.activities)

        # Search by date.
        elif search_by_date and date:
            activities = map(lambda a: (a, to_datetime(a.id.when, TIMEZONE)), activities)
            activities = filter(
                lambda a: a[1] and a[1].date() == date,
                activities
            )
            activities = map(lambda a: a[0], activities)

        # Search by datetime.
        elif search_by_datetime and date_time:
            activities = filter(
                lambda a: a.id.when == activity_id.when,
                activities
            )

        activities = list(activities)
        if len(activities) == 0:
            raise ValueError("Aucune activité trouvée pour:\n" + str(activity_id))
        if len(activities) == 1:
            return activities[0]
        raise ValueError("Critère de recherche trop large. Précisez une date et une heure.")

    def merge_players(self, base, delta, subtract):
        """
        :param base: The array of players the delta must be merged into.
        :param delta: The players to merge into the base.
        :param subtract: Whether the delta is positive or negative.
        """
        result = []
        if subtract:
            delta_gamer_tags = set(map(lambda p: p.gamer_tag, delta))
            result = list(filter(lambda p: p.gamer_tag not in delta_gamer_tags, base))
            del base[:]
            base.extend(result)
        else:
            base_gamer_tags = set(map(lambda p: p.gamer_tag, base))
            players_to_add = list(filter(lambda p: p.gamer_tag not in base_gamer_tags, delta))
            players_to_edit = dict()
            for player in delta:
                if player.gamer_tag in base_gamer_tags:
                    players_to_edit[player.gamer_tag] = player
            for player in base:
                if player.gamer_tag in players_to_edit:
                    player.rating = players_to_edit[player.gamer_tag].rating
            base.extend(players_to_add)

    def assert_player_count_within_bound(self, players, min_capacity, max_capacity):
        """
        :param min_capacity: Minimum expected size. Inclusive.
        :param max_capacity: Maximum expected size. Inclusive.
        :raises: if len(players) is not within the bounds.
        """
        count = len(players)
        if count < min_capacity:
            raise ValueError(
                "Il n'y a pas assez de joueurs %d/%d." % (count, min_capacity)
            )
        if count > max_capacity:
            raise ValueError(
                "Il y a trop de joueurs %d/%d." % (count, max_capacity)
            )
